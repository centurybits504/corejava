package Multuthreading;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class Multiple_ProducersConsumers_With_Executors {

	public static void main(String[] args) {

		ExecutorService prodService =  Executors.newFixedThreadPool(2);
		BlockingQueue<String> sharedQueue = new LinkedBlockingQueue<String>();
		ExecutorService conService = Executors.newFixedThreadPool(2);
		
		prodService.submit(new Producer(sharedQueue,"P1"));
		prodService.submit(new Producer(sharedQueue,"P2"));
		conService.submit(new Consumer(sharedQueue, "C1"));
		conService.submit(new Consumer(sharedQueue, "C2"));
	
	}

}

class Producer implements Runnable{
	BlockingQueue<String> sharedQueue;
	String producer;
	int total = 2; //each producer produces 2 Strings each
	Producer(BlockingQueue<String> sharedQueue,String producer){
		this.sharedQueue = sharedQueue;
		this.producer = producer;
	}
	@Override
	public void run(){
		for(int i=1;i<=total;i++){
			try {
				//Inserts the specified element into this queue, waiting if necessary for space to become available.
				String element = i+producer; 
				sharedQueue.put(element);
				System.out.println("producer("+producer+") produces  ("+ i +producer+")");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		} 
	}
}

class Consumer implements Runnable{
	BlockingQueue<String> sharedQueue;
	String Consumer;
	public Consumer(BlockingQueue<String> sharedQueue, String Consumer) {
		this.sharedQueue = sharedQueue;
		this.Consumer = Consumer;
	}
	@Override
	public void run() {
			while(true){
				try {
					//Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
					String element = sharedQueue.take();
					System.out.println("Consumer("+Consumer+") consumes ("+ element +")");
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
	}	 
}

/*   
One ExecutorService accepts Producer tasks.
One ExecutorService accepts Consumer tasks.
Both Producer and Consumer shares BlockingQueue.
Multiple Producer tasks generates different Strings.
Any of Consumer tasks can consume String generated by Producer
*/
//https://stackoverflow.com/questions/2332537/producer-consumer-threads-using-a-queue